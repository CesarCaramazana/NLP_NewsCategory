# -*- coding: utf-8 -*-
"""NLP_FinalProject_CesarCaramazana.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_Pnr9lV7VrOnKjrxDuWiiPHsLcXvOUeQ

# Natural Language Processing - Final project

___ 

Author: CÃ©sar Caramazana Zarzosa (ccaramaz@pa.uc3m.es)

Date: 27/04/2023

**INTRODUCTION**

In this final project of Natural Language Processing we will be carrying a variety of tasks related to the most important topics we have covered during the course.

We will build an ad hoc corpus from the *News Category Dataset*, publicly available at [Kaggle](https://www.kaggle.com/datasets/rmisra/news-category-dataset). It contains 210k news headlines from 2012 to 2018 from [HuffPost](https://www.huffpost.com/), aswell as a brief description, the author, the date and a label on the category of the piece of news.

## Imports
"""

#Mount Drive
path_to_folder = '/content/drive/My Drive/MASTER/NLP/Project'
import os
from google.colab import drive

# This will prompt for authorization.
drive.mount('/content/drive', force_remount=True)

# Change to assignment directory
os.chdir(path_to_folder)

# Commented out IPython magic to ensure Python compatibility.
#General libraries
import numpy as np
import pandas as pd
import zipfile as zp
from termcolor import colored
import seaborn as sn
import time
import matplotlib.pyplot as plt
# %matplotlib inline
# %config InlineBackend.figure_format = 'retina' 
#To wrap long text lines
from IPython.display import HTML, display

def set_css():
  display(HTML('''
  <style>
    pre {
        white-space: pre-wrap;
    }
  </style>
  '''))
get_ipython().events.register('pre_run_cell', set_css)
# %load_ext google.colab.data_table

#Gensim
!pip install --upgrade gensim==3.8.3

from gensim.models.phrases import Phrases
from gensim.corpora import Dictionary
from gensim.models import TfidfModel
from gensim.models.ldamodel import LdaModel
from gensim.models.coherencemodel import CoherenceModel
from gensim.models.wrappers import LdaMallet
from gensim.models.wrappers.ldamallet import malletmodel2ldamodel
from gensim.models import Word2Vec
from gensim.models import KeyedVectors
from gensim.models import FastText

class IterableSentence_fromfile(object):
    def __init__(self, filename):
        self.__filename = filename
    
    def __iter__(self):
        for line in open(self.__filename):
            # assume there's one sentence per line, tokens separated by whitespace
            yield line.split()

# Mallet
import os       #importing os to set environment variable
def install_java():
    !apt-get install -y openjdk-8-jdk-headless -qq > /dev/null      #install openjdk
    os.environ["JAVA_HOME"] = "/usr/lib/jvm/java-8-openjdk-amd64"     #set environment variable
    !java -version       #check java version
install_java()

#For visualization
!pip install pyLDAvis==2.1.2
import pyLDAvis.gensim as gensimvis
import pyLDAvis

#Scikit

#Preprocessing: normalization, split, categorical label encoder
from sklearn.model_selection import train_test_split
from sklearn import preprocessing
from collections import Counter #To count how many samples of each class
from sklearn.preprocessing import LabelEncoder

#Cross validation
from sklearn.model_selection import GridSearchCV

#Models
from sklearn.ensemble import RandomForestClassifier
from sklearn.ensemble import ExtraTreesClassifier
from sklearn.svm import LinearSVC
from sklearn.svm import SVC
from sklearn.neural_network import MLPClassifier

#Metrics 
from sklearn import metrics

# Commented out IPython magic to ensure Python compatibility.
# From the Hugging Face tutorial
import importlib, os

necessary_packages = ['transformers[sentencepiece]', 'datasets', 'gradio', 'colored', 'wikipedia', 'evaluate', 'nltk', 'rouge_score']
def import_missing(packages):
  for p in packages:
    try:
      mod = importlib.import_module(p)
      print(f"Package {p} already installed!")
      packages.remove(p)
    except ModuleNotFoundError:
      print(f"Installing package {p}")
      with open("requirements.txt", 'w') as f:
        f.write("\n".join(str(i) for i in packages))
  if os.path.isfile("requirements.txt"):
#     %pip install --quiet -r "requirements.txt"

import_missing(necessary_packages)

# Supress future warnings
import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)
warnings.filterwarnings("ignore", category=DeprecationWarning)

"""## **0. DATA ACQUISITION AND PREPROCESSING PIPELINE**

**IMPORTANT NOTE**: this section was executed in a different notebook and the output was saved in a .json file that is directly loaded in section 1. This is mainly due to the fact that the retrieval from the web (0.1) took several hours and had to be done in chunks of 500 samples at the time, instead of all 16.5k at once, as it is defined here. 

___

Given that the headline and the short description is just a few words long --which would hinder some of the tasks, particularily Topic Modeling--, we are going to **generate a subpartition of the dataset with the whole body of the articles**, retrieved from the original source website. 

Then, we'll clean the text, and save the processed data in a new file to avoid having to execute these cells every time (which are very time consuming). 
"""

#Load the original News Category dataset
df = pd.read_json('./Dataset/News_Category_Dataset_v3.json', lines=True)

"""### 0.1 Website retrieval

The following function retrieves the text tagged as ```<p>``` in the HTLM of a website. 
"""

import requests
from bs4 import BeautifulSoup

def retrieve_text(url):
  """
  Retrieves the text of a website (tagged as <p> in the HTML source).

  Args:
    url: (str) link to the website.

  Returns:
    output: (str) retrieved text.  

  """
  res = requests.get(url)
  html_page = res.content
  soup = BeautifulSoup(html_page, 'html.parser')
  text = soup.find_all(text=True)

  output = ''

  for t in text:
    if t.parent.name == 'p':
        output += '{} '.format(t)

  return output

"""We apply the retrieval to the first 16.5k\* entries of the dataframe.


"""

# 1) Select first 16500 entries
df_short = df[0:16500]


# 2) Apply URL retrieval
df_short['news_corpus'] = df_short['link'].apply(retrieve_test)

"""\* *We take only 16.5k samples instead of the whole 210k due to: 1) the unavailability of some of the samples after the HuffPost stopped maintaining an archive, which doesn't allow us to fully automate the retrieval, 2) time constraints, as the process takes a few hours and Colab is prone to disconnections, and 3) pragmatism since, as we will see, the final corpus will contain more than enough samples to carry out the tasks.*

### 0.2 Text preprocessing

The rawtext is processed through the following pipeline that returns the lemmatized lowercased tokens after applying valid Part-of-Speech filtering and stopword removal.

We realized that every entry contained a disclaimer: "*By entering your email and clicking Sign Up, you're agreeing to let us send you customized marketing messages about us and our advertising partners*", which was eliminated via specific stopword removal as it hindered the LDA topic modeling task.
"""

!python -m spacy download en_core_web_md

nlp = spacy.load('en_core_web_md')
nlp.disable_pipe('parser')
nlp.disable_pipe('ner')

valid_POS = set(['VERB', 'NOUN', 'ADJ', 'PROPN'])
specific_stw = set(['agreeing', 'email', 'people', 'year','man', 'new','woman',
                    'clicking', 'say','sign','message', 'advertising', 'let', 'send', 
                    'reporter', 'click', 'enter', 'sign', 'customized', 'messages', 'twitter', 
                    'editor', 'huffpost', 'agree', 'customize', 'marketing', 'partner'])

def text_preprocessing(rawtext):
    """
    Cleans an input raw text applying the following steps:
      - Part-of-Speech filtering (keeping verbs, nouns, pronouns and adjectives)
      - Alpha numeric filtering
      - Generic stopword removal
      - Specific stopword removal
      - Lemmatization
      - To lower-case

    Args:
      rawtext: (str) text to preprocess.

    Returns:
      lemma: (list) lemmatized tokens as list.    
    
    """
  
    doc = nlp(rawtext)

    lemma = [token.lemma_.lower() for token in doc if token.is_alpha 
             and token.pos_ in valid_POS 
             and not token.is_stop 
             and token.lemma_.lower() not in specific_stw]
    
    return lemma

"""The cleaned text is stored as a column in the dataframe. The dataframe is saved as a json file for further reuse."""

# 1) Join the headline and the corpus
df_short['news'] = (df_short['headline'] + '. ' + df_short['news_corpus']).astype(str)

# 2) Apply cleaning pipeline
df_short['news_clean'] = df_short['news'].apply(text_preprocessing)


# 3) Save the dataframe in a json file
path = './Dataset/Final_NewsCorpus_Clean.json'
df_short.to_json(path)

"""## **1. DATA LOADING**

Load the data we preprocessed in section 0. as a Pandas dataframe.
"""

# Read dataframe
corpus_df = pd.read_json('./Dataset/Final_NewsCorpus_Clean.json')

# Corpus
mycorpus = [doc for doc in corpus_df['news_clean']]

print("The corpus contains %1i documents. " %len(corpus_df))

"""\* *NOTE: one entry was removed because it yielded an error in the word embedding vectorization*.

### 1.1 Preprocessing

The only preprocessing we do to the final corpus is bi-gram detection, as many terms in the *News Dataset* are diadic and appear very often. For example: 'White House', 'United States', 'Health Care', etc (see section 1.2).

We also tried to detect tri-grams such as 'New York City' or 'President Donald Trump', but we discarded it after not being able to select a proper threshold to avoid false positives.
"""

# 1) N-gram detection

#Bigrams
phrase_model = Phrases(mycorpus, min_count=2, threshold=10)
mycorpus = [el for el in phrase_model[mycorpus]]

"""### 1.2 Data analysis

1) **Distribution of documents per labeled *CATEGORY*.**

The original dataset presented 42 categories. Our subpartition only contains 35.
"""

categories = np.unique(corpus_df['category'])
num_news = []

for cat in categories:
  num_news.append(len(np.where(corpus_df['category'] == cat)[0]))

plt.figure(figsize=(16,6))
plt.title("Number of pieces of news per category")
plt.bar(categories, num_news)
#plt.yscale('log')
plt.xticks(ticks=range(len(categories)), labels=categories, rotation=90)
plt.show()

"""The dataset is **highly imbalanced**, with the category *POLITICS* representing almost the 50\% of the samples. The second and third most represented categories are *ENTERTAINMENT* and *WORLD NEWS*, which are very generic categories in comparison with the more specific *LATINO VOICES* or *TECH*, which barely have a few dozens of samples.



It is also worth mentioning that the HuffPost is an American newsletter, and therefore all the content is biased towards the reality of the United States, even if there is a specific *U.S. NEWS* category.

2) **N-grams**
"""

tokens_Ngrams = []

for doc in mycorpus:
  for token in doc:
    if '_' in token:
      tokens_Ngrams.append(token)

Ngrams, counts = np.unique(np.array(tokens_Ngrams), return_counts=True)

import pandas as pd

data = {'Ngram': Ngrams, 'Counts': counts}

Ngrams_df = pd.DataFrame(data)
Ngrams_df.sort_values(by=['Counts'], ascending=False, inplace=True)

# Top 10 most common N_grams
Ngrams_df.head(20)

"""**3) Average number of words per doc**"""

n_words = []

for doc in mycorpus:
  n_words.append(len(doc))

print("Average number of words per article: ", np.mean(np.array(n_words)))

#Filter out extreme to better visualize the histogram
n_words = [n for n in n_words if n < 2000]  
plt.figure(figsize=(7,5))
plt.title("Words per article")
plt.hist(n_words, bins=1024)
plt.show()

"""## **2. VECTOR REPRESENTATIONS**

In this section we perform the vectorization of the document via: Bag-of-words, TFIDF, document embedding, LDA topic modeling and Neural topic modeling.

### 2.1 Dictionary and BoW

After creating the dictionary, we filter out very uncommon terms (that appear in less than 10 articles) and very common ones (on more than 80% of the articles). This is useful not only to reduce the dimensionality of the TFIDF matrix, but also for a better result in the topic modeling task.
"""

no_below = 10 #Minimum number of documents to keep a term in the dictionary
no_above = .80 #Maximum proportion of documents in which a term can appear to be kept in the dictionary

D = Dictionary(mycorpus)
D.filter_extremes(no_below=no_below,no_above=no_above)

mycorpus_bow = [D.doc2bow(doc) for doc in mycorpus]

print("Dictionary contains %i words" %len(D))

"""### 2.2 TFIDF

The TF-IDF matrix is directly calculated from the BoW representation.
"""

tfidf = TfidfModel(mycorpus_bow)

mycorpus_tfidf = tfidf[mycorpus_bow]

"""### 2.3 Word Embeddings

Here we train a Fast Text model with embedding size = 200. The keyed vectors are then saved for better re-use.
"""

from gensim.models import FastText

# 1) Obtain w2v model and save it
model_fasttext = FastText(sentences=mycorpus, size=200, window=5, min_count=2, seed=42)

#Save Fast Text model with vector_size = 200
wv = model_fasttext.wv
wv.save("./W2V/fasttext_200.wordvectors")

import gc
del model_fasttext
gc.collect()

# 2) Load keyed vectors

wv = KeyedVectors.load("./W2V/fasttext_200.wordvectors", mmap='r')

"""There are many strategies we could implement a function to obtain the embedding of a document. Here, we compute the doc embedding V as **the tfidf-weighted average of the word embeddings**. That is, for each word in a document, we multiply its embedding times its tf-idf factor. Then, add all the embeddings together and divide by the document length.


<p><center>
$V(doc) = \frac{1}{Nwords}\sum_{word}^{} tfidf(word, doc)V(word)$

</center></p>


With this approach we aim to module the contribution of common/uncommon terms in the embedding space.

"""

# 3) Get single embedding as mean of word embeddings in the News text

def get_mean_vector(model, doc_tfidf, D):
  """
  Calculates a document embedding representation by weighting the embeddings of the words with their tf-idf factor.

  Args:
    model: (word vectors) word2vec model with the embeddings of all the words.
    doc_tfidf: (list) list containing the tf-idf weights of the document. 
    D: (dictionary) dictionary obtained from the corpora.

  Returns:
    vec: (np.array) document embedding.  

  """
 
  embeddings = []
  eps = 1e-9
  for i in doc_tfidf:
    # 1) Word embedding
    word = D[i[0]]
    word_emb = model[word]

    # 2) TDIDF weight
    weight = i[1]

    # 3) Weighted embedding
    embeddings.append(word_emb * weight + eps)

  #print(len(embeddings))
  vec = np.mean(np.asarray(embeddings), axis=0)

  return vec

# 4) Create matrix of size [N_docs, embedding_size] with the mean embedding of each doc

embedding_size = wv.vector_size
N_news = len(mycorpus)

X_w2v = np.zeros((N_news, embedding_size))

for i in range(len(mycorpus_tfidf)):  
  vec = get_mean_vector(wv, mycorpus_tfidf[i], D)

  X_w2v[i] = vec

"""### 2.4 LDA Topic modeling


In this section we carry out a Latent Dirichlet Allocation topic modeling. To select the number of topics, we first perform a search over a set of values, ```[15, 20, 30, 35, 40, 45, 50, 60, 70]```, a keep the one that yields the highest coherence. 

*NOTE: this search was executed several times (to iteratively improve the preprocessing pipeline) and the optimal value differed between 40, 45 and 50. By inspecting the contents of the topics in each case, we didn't notice a significant change.*
"""

!wget http://mallet.cs.umass.edu/dist/mallet-2.0.8.zip
!unzip mallet-2.0.8.zip

os.environ['MALLET_HOME'] = 'mallet-2.0.8'
mallet_path = 'mallet-2.0.8/bin/mallet' # you should NOT need to change this

# Mallet LDA

n_topics = [15, 20, 30, 35, 40, 45, 50, 60, 70]

# 1) Select number of topics based on coherence score
coherence =[]
for n in n_topics:
  ldamallet = LdaMallet(mallet_path, corpus=mycorpus_bow, num_topics=n, id2word=D, alpha=5, iterations=50)
  ldagensim = malletmodel2ldamodel(ldamallet)

  coherencemodel = CoherenceModel(ldagensim, texts=mycorpus, dictionary=D, coherence='c_v')

  print("Estimating coherence for model with %i topics ===========================" %n)
  c = coherencemodel.get_coherence()
  coherence.append(c)

  print("Coherence = %4.4f" %c)
  print()

plt.title("Coherence vs number of topics (Mallet)")
plt.plot(n_topics, coherence)
plt.xlabel("N topics")
plt.ylabel("Coherence")

plt.show()

# 2) Re-train model with highest coherence for more iterations

n_topic = n_topics[np.argmax(coherence)]
#n_topic = 50

print("Final number of topics: ", n_topic)


ldamallet = LdaMallet(mallet_path, corpus=mycorpus_bow, num_topics=n_topic, id2word=D, alpha=5, iterations=200)
ldagensim = malletmodel2ldamodel(ldamallet)

topics_in_doc = ldagensim.get_document_topics(mycorpus_bow)

"""Now we visualize the obtained topics and check if they relate to any of the categories we have in the labels or to any of the events that have been covered in the news during the past few years. 

"""

# 3) Visualize topic representation of corpus with LDAvis

vis_data = gensimvis.prepare(ldagensim, mycorpus_bow, D)
pyLDAvis.display(vis_data)

"""Some of the most easily identifiable topics are:

*   [28] Covid19 pandemic.
*   [38] Russia-Ukraine war.
*   [12] and [23] American presidential elections.
*   [4] Donald Trump.
*   [10] Movies, cinema, Hollywood. 
*   [35] Gun shootings.
*   [22] Racism.
*   [11] Sexual abuse/allegations.
*   [36] Education, schools, University. 
*   [39] Religion.
*   [26] Climate change.

## **3. CLASSIFICATION TASK**

In this part we will carry out a supervised classification task, using the different **document vector representations** we obtained in 2, and comparing the performance of **classical Machine Learning methods**, such as Support Vector Machines (SVM), Random Forests (RF) and Multilayer Perceptrons (MLP), with **fine-tuned Transformers** from the Hugging Face library. 

Performance will be evaluated in terms of accuracy and inference time. The confusion matrix will also be plotted for further analysis of the results in the report.

### 3.1 Preprocessing

As we saw in 1.2, the dataset is highly unbalanced in terms of documents per category. In order to simplify the problem, we select *POLITICS*, *WORLD NEWS* and *ENTERTAINMENT* as stand alone classes and merge everything else into an *OTHER* class.
"""

#Categorical labels
Y_cat = corpus_df['category'].values

Y = np.zeros((len(Y_cat)), dtype=int)

#Simplify the problem to 4 classes: 'OTHER': 0, 'POLITICS': 1, 'WORLD NEWS': 2, 'ENTERTAINMENT': 3
Y[np.where(Y_cat == 'POLITICS')] = 1
Y[np.where(Y_cat == 'WORLD NEWS')] = 2
Y[np.where(Y_cat == 'ENTERTAINMENT')] = 3

Yclasses = ["OTHER", "POLITICS", "WORLD NEWS", "ENTERTAINMENT"]

print(Counter(Y))

categories = np.unique(Y)
num_news = []

for cat in categories:
  num_news.append(len(np.where(Y == cat)[0]))

plt.figure(figsize=(8,5))
plt.title("Number of pieces of news per category")
plt.bar(categories, num_news, color='r')
#plt.yscale('log')
plt.xticks(ticks=range(len(categories)), labels=Yclasses, rotation=0)
plt.show()

"""### 3.2 TFIDF"""

from gensim.matutils import corpus2dense, corpus2csc
from scipy.sparse import lil_matrix, csr_matrix

#FROM SPARSE TO DENSE TFIDF REPRESENTATION
num_docs = D.num_docs
num_terms = len(D.keys())

tfidf_dense = np.transpose(corpus2dense(mycorpus_tfidf, num_terms, num_docs))

#BACK TO SPARSE
X_tfidf = lil_matrix(tfidf_dense)
print(X_tfidf.shape)

# TRAIN-TEST SPLIT
X_tfidf_train, X_tfidf_test, Y_train, Y_test = train_test_split(X_tfidf, Y, test_size = 0.35, random_state = 42, stratify=Y)

print("Train: ", X_tfidf_train.shape[0])
print("Test: ", X_tfidf_test.shape[0])

"""#### 3.2.1 SVM"""

rang_C = [1, 3, 6]
kernels = ['rbf']

tuned_parameters = {
    'C': rang_C,
    'kernel': kernels
}

clf = SVC()

svm = GridSearchCV(clf, param_grid=tuned_parameters, cv=5)

svm.fit(X_tfidf_train, Y_train)

print(svm.best_estimator_)


# -----------------------------------------------------------------
train_accuracy = svm.score(X_tfidf_train, Y_train)

tik = time.process_time()
test_accuracy = svm.score(X_tfidf_test, Y_test)
tok = time.process_time()

print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/X_tfidf_test.shape[0]))

# Test confusion matrix
Y_pred = svm.predict(X_tfidf_test)

CM = metrics.confusion_matrix(Y_test, Y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""#### 3.2.2 Random Forest"""

T = 100
num_trees = range(5, T, 5)
depth = [2, 3]

tuned_parameters = {
    'n_estimators': num_trees,
    'max_depth': depth
}

clf = RandomForestClassifier()

rf = GridSearchCV(clf, tuned_parameters, cv=5)
rf.fit(X_tfidf_train, Y_train)

print(rf.best_estimator_)
# -----------------------------------------------------------------
train_accuracy = rf.score(X_tfidf_train, Y_train)

tik = time.process_time()
test_accuracy = rf.score(X_tfidf_test, Y_test)
tok = time.process_time()

print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/X_tfidf_test.shape[0]))


# Test confusion matrix
Y_pred = rf.predict(X_tfidf_test)

CM = metrics.confusion_matrix(Y_test, Y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""#### 3.2.2 MLP"""

optimizer = ['adam']

tuned_parameters = {
    'solver': optimizer,
}

clf = MLPClassifier(hidden_layer_sizes = (128, 256, 128), early_stopping=True, random_state = 42, max_iter = 1000)

mlp = GridSearchCV(clf, tuned_parameters, cv=5)

mlp.fit(X_tfidf_train, Y_train)

print(mlp.best_estimator_)

# -----------------------------------------------------------------
train_accuracy = mlp.score(X_tfidf_train, Y_train)

tik = time.process_time()
test_accuracy = mlp.score(X_tfidf_test, Y_test)
tok = time.process_time()

print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/X_tfidf_test.shape[0]))


# Test confusion matrix
Y_pred = mlp.predict(X_tfidf_test)

CM = metrics.confusion_matrix(Y_test, Y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""### 3.3 Word Embeddings"""

# TRAIN-TEST SPLIT
X_w2v_train, X_w2v_test, Y_train, Y_test = train_test_split(X_w2v, Y, test_size = 0.35, random_state = 42, stratify=Y)

print("Trainset class balance: ", Counter(Y_train))
print("Testset class balance: ", Counter(Y_test))

# NORMALIZATION
scaler = preprocessing.StandardScaler().fit(X_w2v_train)

X_w2v_train = scaler.transform(X_w2v_train) 
X_w2v_test = scaler.transform(X_w2v_test)

"""#### 3.3.1 SVM"""

rang_C =  range(1, 10, 1)
kernels = ['rbf']

tuned_parameters = {
    'C': rang_C,
    'kernel': kernels
}

clf = SVC()

svm = GridSearchCV(clf, param_grid=tuned_parameters, cv=5)

svm.fit(X_w2v_train, Y_train)

print(svm.best_estimator_)


# -----------------------------------------------------------------
train_accuracy = svm.score(X_w2v_train, Y_train)

tik = time.process_time()
test_accuracy = svm.score(X_w2v_test, Y_test)
tok = time.process_time()

print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/X_w2v_test.shape[0]))

# Test confusion matrix
Y_pred = svm.predict(X_w2v_test)

CM = metrics.confusion_matrix(Y_test, Y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""#### 3.3.2 Random Forest"""

T = 100
num_trees = range(5, T, 5)
depth = [2, 3]

tuned_parameters = {
    'n_estimators': num_trees,
    'max_depth': depth
}

clf = RandomForestClassifier()

rf = GridSearchCV(clf, tuned_parameters, cv=5)
rf.fit(X_w2v_train, Y_train)

print(rf.best_estimator_)
# -----------------------------------------------------------------
train_accuracy = rf.score(X_w2v_train, Y_train)

tik = time.process_time()
test_accuracy = rf.score(X_w2v_test, Y_test)
tok = time.process_time()

print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/X_w2v_test.shape[0]))


# Test confusion matrix
Y_pred = rf.predict(X_w2v_test)

CM = metrics.confusion_matrix(Y_test, Y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""#### 3.3.3 MLP"""

optimizer = ['adam']

tuned_parameters = {
    'solver': optimizer,
}

clf = MLPClassifier(hidden_layer_sizes = (128, 256, 128), early_stopping=True, random_state = 42, max_iter = 1000)

mlp = GridSearchCV(clf, tuned_parameters, cv=5)

mlp.fit(X_w2v_train, Y_train)

print(mlp.best_estimator_)


# -----------------------------------------------------------------
train_accuracy = mlp.score(X_w2v_train, Y_train)

tik = time.process_time()
test_accuracy = mlp.score(X_w2v_test, Y_test)
tok = time.process_time()

print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/X_w2v_test.shape[0]))


# Test confusion matrix
Y_pred = mlp.predict(X_w2v_test)

CM = metrics.confusion_matrix(Y_test, Y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""### 3.4 LDA Topic representation"""

from gensim.matutils import corpus2dense, corpus2csc
from scipy.sparse import lil_matrix, csr_matrix

#FROM SPARSE TO DENSE TOPIC REPRESENTATION
num_docs = D.num_docs

mycorpus_topics = np.transpose(corpus2dense(topics_in_doc, n_topic, num_docs))

#BACK TO SPARSE
X_topics = lil_matrix(mycorpus_topics)
print(X_topics.shape)

# TRAIN-TEST SPLIT
X_topics_train, X_topics_test, Y_train, Y_test = train_test_split(X_topics, Y, test_size = 0.35, random_state = 42, stratify=Y)

print("Train: ", X_topics_train.shape[0])
print("Test: ", X_topics_test.shape[0])

"""#### 3.4.1 SVM"""

rang_C =  range(1, 10, 1)
kernels = ['rbf']

tuned_parameters = {
    'C': rang_C,
    'kernel': kernels
}

clf = SVC()

svm = GridSearchCV(clf, param_grid=tuned_parameters, cv=5)

svm.fit(X_topics_train, Y_train)

print(svm.best_estimator_)


# -----------------------------------------------------------------
train_accuracy = svm.score(X_topics_train, Y_train)

tik = time.process_time()
test_accuracy = svm.score(X_topics_test, Y_test)
tok = time.process_time()

print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/X_topics_test.shape[0]))

# Test confusion matrix
Y_pred = svm.predict(X_topics_test)

CM = metrics.confusion_matrix(Y_test, Y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""#### 3.4.2 Random Forest"""

T = 100
num_trees = range(5, T, 5)
depth = [2, 3]

tuned_parameters = {
    'n_estimators': num_trees,
    'max_depth': depth
}

clf = RandomForestClassifier()

rf = GridSearchCV(clf, tuned_parameters, cv=5)
rf.fit(X_topics_train, Y_train)

print(rf.best_estimator_)

# -----------------------------------------------------------------
train_accuracy = rf.score(X_topics_train, Y_train)

tik = time.process_time()
test_accuracy = rf.score(X_topics_test, Y_test)
tok = time.process_time()

print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/X_topics_test.shape[0]))


# Test confusion matrix
Y_pred = rf.predict(X_topics_test)

CM = metrics.confusion_matrix(Y_test, Y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""#### 3.4.3 MLP"""

optimizer = ['adam']

tuned_parameters = {
    'solver': optimizer,
}

clf = MLPClassifier(hidden_layer_sizes = (128, 256, 128), early_stopping=True, random_state = 42, max_iter = 1000)

mlp = GridSearchCV(clf, tuned_parameters, cv=5)

mlp.fit(X_topics_train, Y_train)

print(mlp.best_estimator_)

# -----------------------------------------------------------------
train_accuracy = mlp.score(X_topics_train, Y_train)

tik = time.process_time()
test_accuracy = mlp.score(X_topics_test, Y_test)
tok = time.process_time()

print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/X_topics_test.shape[0]))


# Test confusion matrix
Y_pred = mlp.predict(X_topics_test)

CM = metrics.confusion_matrix(Y_test, Y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""### 3.5 Transformers

For the fine-tuning of a pretrained Transformer, we need to follow a few extra steps.

First, for the sake of simplicity, we are going to create a new dataframe with just the text of the articles (as the strings directly retrieved from the website) and the one-hot encoded labels, as it is required for the model.
"""

from sklearn.preprocessing import OneHotEncoder

#One-hot encode labels (as expected from the model)
Y_oh = list(OneHotEncoder(sparse_output=False).fit_transform(Y[:,None]))

#Create a new dataframe with just the text and the label

news_dataframe = corpus_df[['news']].copy()
news_dataframe['labels'] = Y_oh

"""We split train and test, returning the same partition we got with the previous methods. Then, we further split train into train and validation."""

# TRAIN-TEST SPLIT
train_valid, test, Ytrain_val, Ytest = train_test_split(news_dataframe, Y, test_size = 0.35, random_state = 42, stratify=Y)

# SPLIT TRAIN INTO TRAIN AND VALIDATION TO LEAVE THE TEST SET UNTOUCHED
train, val, Ytrain, Yval = train_test_split(train_valid, Ytrain_val, test_size = 0.2, random_state=42, stratify=Ytrain_val)

"""Create a DatasetDict object with the three sets."""

from datasets import DatasetDict, Dataset

news_dataset = DatasetDict({
    "train": Dataset.from_pandas(train),
    "test": Dataset.from_pandas(test),
    "val": Dataset.from_pandas(val),
    })

news_dataset

"""We select the **DistilBERT** model from the Hugging Face library, as it is one of the many architectures suitable for text classification. 

In the following cell we define the tokenizer from the checkpoint and apply it to the dataset.
"""

from transformers import AutoTokenizer

checkpoint_name = "distilbert-base-uncased"
tokenizer = AutoTokenizer.from_pretrained(checkpoint_name)


def preprocess_function(example):
    return tokenizer(example["news"], padding=True, truncation=True)

#Tokenize dataset
tokenized_news = news_dataset.map(preprocess_function)

"""Now we define the collator and the training arguments. Except for the *output directory*, the rest have been left as they are by default. For the evaluation of the training process we define the ```compute_metrics``` function as the **accuracy score**. """

from transformers import DataCollatorWithPadding
from transformers import TrainingArguments
import evaluate


data_collator = DataCollatorWithPadding(tokenizer=tokenizer)

training_args = TrainingArguments(
    output_dir=f"{checkpoint_name}-finetuned",
    per_device_train_batch_size=16,                                             
    per_device_eval_batch_size=16,                                              
    num_train_epochs=5,                                                         
    evaluation_strategy="epoch",                                                
    logging_strategy="epoch",                                                   
    save_strategy="epoch",                                                      
    learning_rate=2e-5,                                                         
    load_best_model_at_end=True,                                                
    metric_for_best_model='accuracy',                                           
    seed=42,                                                                    
)

accuracy = evaluate.load("accuracy")

def compute_metrics(eval_pred):
    predictions, labels = eval_pred
    predictions = np.argmax(predictions, axis=1)
    labels = np.argmax(labels, axis=1)
    return accuracy.compute(predictions=predictions, references=labels)

"""Instantiate the model for multilabel sequence classification. """

from transformers import AutoModelForSequenceClassification

id2label = {0: "OTHER", 1: "POLITICS", 2: "WORLD NEWS", 3: "ENTERTAINMENT"}
label2id = {"OTHER": 0, "POLITICS": 1, "WORLD NEWS": 2, "ENTERTAINMENT": 3}

model = AutoModelForSequenceClassification.from_pretrained(checkpoint_name, 
                                                           num_labels=4, 
                                                           id2label=id2label, 
                                                           label2id=label2id,
                                                           problem_type="multi_label_classification")

from transformers import Trainer, EarlyStoppingCallback

trainer = Trainer(
    model=model,
    args=training_args,
    train_dataset=tokenized_news["train"],
    eval_dataset=tokenized_news["val"],
    data_collator=data_collator,
    tokenizer=tokenizer,
    compute_metrics=compute_metrics,
    callbacks = [EarlyStoppingCallback(early_stopping_patience=1, early_stopping_threshold=0.0)]

)

trainer.train()

"""Evaluate the model as previously done."""

# TEST
# -----------------------------------------------------------------

#Train
train_predictions = trainer.predict(tokenized_news["train"])
y_pred = np.argmax(train_predictions.predictions, axis=1)
train_accuracy = metrics.accuracy_score(y_true = Ytrain, y_pred = y_pred)


#Test
tik = time.process_time()
test_predictions = trainer.predict(tokenized_news["test"])
tok = time.process_time()

y_pred = np.argmax(test_predictions.predictions, axis=1)

test_accuracy = metrics.accuracy_score(y_true = Ytest, y_pred = y_pred)


print("\nTrain accuracy = %.4f " %train_accuracy)
print("Test accuracy = %.4f" %test_accuracy)

print("\nAverage test inference time = %4.7f [s/sample]" %((tok-tik)/len(Ytest)))

CM = metrics.confusion_matrix(Ytest, y_pred, normalize='true')
plt.figure(figsize=(7,5))
sn.heatmap(CM, annot=True, xticklabels = Yclasses, yticklabels=Yclasses)
plt.show()

"""### 3.6 Summary of the results


![results.PNG](data:image/png;base64,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)

## References

1. Misra, Rishabh. "News Category Dataset." arXiv preprint arXiv:2209.11429 (2022).
2. Misra, Rishabh and Jigyasa Grover. "Sculpting Data for ML: The first act of Machine Learning." ISBN 9798585463570 (2021).
3. Piotr Bojanowski et al. âEnriching Word Vectors with
Subword Informationâ. In: Transactions of the Associ-
ation for Computational Linguistics 5 (2017), pp. 135â146. ISSN: 2307-387X.
4.Andrew Kachites McCallum. âMALLET: A
Machine Learning for Language Toolkitâ.
http://mallet.cs.umass.edu. 2002.
5. Carson Sievert and Kenneth Shirley. âLDAvis: A
method for visualizing and interpreting topicsâ. In:
Proceedings of the workshop on interactive language
learning, visualization, and interfaces. 2014, pp. 63â70.
6. Victor Sanh et al. âDistilBERT, a distilled version of
BERT: smaller, faster, cheaper and lighterâ. In: ArXiv
abs/1910.01108 (2019).
7. Huffpost. URL: https://www.huffpost.com/.
"""